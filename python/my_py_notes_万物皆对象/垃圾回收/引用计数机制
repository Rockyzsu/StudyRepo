引⽤计数机制的优点：
    简单
    实时性： ⼀旦没有引⽤， 内存就直接释放了。 不⽤像其他机制等到特定
    时机。 实时性还带来⼀个好处： 处理回收内存的时间分摊到了平时。

引⽤计数机制的缺点：
1. 维护引⽤计数消耗资源
2. 循环引⽤
    list1 = []
    list2 = []
    list1.append(list2)
    list2.append(list1)
list1与list2相互引⽤, 如果不存在其他对象对它们的引⽤,
list1与list2的引⽤计数也仍然为1, 所占⽤的内存永远⽆法被回收
这将是致命的. 对于如今的强⼤硬件, 缺点1尚可接受
但是循环引⽤导致内存泄露, 注定python还将引⼊新的回收机制。 (分代收集)

Python中的垃圾回收是以引⽤计数为主， 分代收集为辅。
1、 导致引⽤计数+1的情况
    对象被创建， 例如a=23
    对象被引⽤， 例如b=a
    对象被作为参数， 传⼊到⼀个函数中， 例如func(a)
    对象作为⼀个元素， 存储在容器中， 例如list1=[a,a]
2、 导致引⽤计数-1的情况
    对象的别名被显式销毁， 例如del a
    对象的别名被赋予新的对象， 例如a=24
    ⼀个对象离开它的作⽤域， 例如f函数执⾏完毕时， func函数中的局部变量（ 全局
    变量不会）
    对象所在的容器被销毁， 或从容器中删除对象
3、 查看⼀个对象的引⽤计数
    import sys
    a = "hello world"
    sys.getrefcount(a)
    可以查看a对象的引⽤计数， 但是⽐正常计数⼤1， 因为调⽤函数的时候传⼊a， 这会让a的引⽤计数+1

## 有三种情况会触发垃圾回收：
1. 当gc模块的计数器达到阀值的时候， ⾃动回收垃圾
2. 调⽤gc.collect()， ⼿动回收垃圾
3. 程序退出的时候， python解释器来回收垃圾

## gc模块的⾃动垃圾回收触发机制
在Python中, 采⽤分代收集的⽅法. 把对象分为三代
⼀开始, 对象在创建的时候, 放在⼀代中,
如果在⼀次⼀代的垃圾检查中, 改对象存活下来,
就会被放到⼆代中, 同理在⼀次⼆代的垃圾检查中, 该对象存活下来, 就会被放到三代中。
gc模块⾥⾯会有⼀个⻓度为3的列表的计数器， 可以通过gc.get_count()获取。

eg: (488,3,0)， 其中488是指距离上⼀次⼀代垃圾检查， Python分配内存的
数⽬减去释放内存的数⽬， 注意是内存分配， ⽽不是引⽤计数的增加。
eg:
print gc.get_count() # (590, 8, 0)
a = ClassA()
print gc.get_count() # (591, 8, 0)
del a
print gc.get_count() # (590, 8, 0)

3是指距离上⼀次⼆代垃圾检查, ⼀代垃圾检查的次数,
同理, 0是指距离上⼀次三代垃圾检查, ⼆代垃圾检查的次数.
gc模快有⼀个⾃动垃圾回收的 阀值,
即通过gc.get_threshold函数获取到的⻓度为3的元组，

eg: (700,10,10) 每⼀次计数器的增加, gc模块就会检查增
加后的计数是否达到阀值的数⽬， 如果是， 就会执⾏对应的代数的垃圾检查， 然后重置计数器
eg: 假设阀值是(700,10,10)：
当计数器从(699,3,0)增加到(700,3,0)， gc模块就会执⾏gc.collect(0),即
检查⼀代对象的垃圾， 并重置计数器为(0,4,0)
当计数器从(699,9,0)增加到(700,9,0)， gc模块就会执⾏gc.collect(1),即
检查⼀、 ⼆代对象的垃圾， 并重置计数器为(0,0,1)
当计数器从(699,9,9)增加到(700,9,9)， gc模块就会执⾏gc.collect(2),即
检查⼀、 ⼆、 三代对象的垃圾， 并重置计数器为(0,0,0)

## 循环引⽤导致内存泄露
内存泄漏
申请了某些内存， 但是忘记了释放， 那么这就造成了内存的浪费， 久⽽久之内存就不
够⽤了

1. 让程序产⽣内存泄漏
import gc
class ClassA():
    def __init__(self):
        print('object born,id:%s'%str(id(self)))
    def f2():
        while True:
            c1 = ClassA()
            c2 = ClassA()
            c1.t = c2
            c2.t = c1
            del c1
            del c2

#python默认是开启垃圾回收的， 可以通过下⾯代码来将其关闭
gc.disable()

f2()
执⾏f2()， 进程占⽤的内存会不断增⼤。
创建了c1， c2后这两块内存的引⽤计数都是1, 执⾏ c1.t=c2 和 c2.t=c1 后， 这两块内存的引⽤计数变成2

在del c1后, 引⽤计数变为1, 由于不是为0, 所以c1对象不会被销毁;
同理, c2对象的引⽤数也是1。
python默认是开启垃圾回收功能的， 但是由于以上程序已经将其关闭，
因此导致垃圾回收器都不会回收它们， 所以就会导致内存泄露